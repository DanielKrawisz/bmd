// Code generated by protoc-gen-go.
// source: rpc.proto
// DO NOT EDIT!

/*
Package rpcproto is a generated protocol buffer package.

It is generated from these files:
	rpc.proto

It has these top-level messages:
	GetIdentityRequest
	GetIdentityReply
	Object
	SendObjectReply
	GetObjectsRequest
*/
package rpcproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ObjectType is an enum which contains various types of objects.
type ObjectType int32

const (
	ObjectType_GETPUBKEY ObjectType = 0
	ObjectType_PUBKEY    ObjectType = 1
	ObjectType_MESSAGE   ObjectType = 2
	ObjectType_BROADCAST ObjectType = 3
	ObjectType_UNKNOWN   ObjectType = 99
)

var ObjectType_name = map[int32]string{
	0:  "GETPUBKEY",
	1:  "PUBKEY",
	2:  "MESSAGE",
	3:  "BROADCAST",
	99: "UNKNOWN",
}
var ObjectType_value = map[string]int32{
	"GETPUBKEY": 0,
	"PUBKEY":    1,
	"MESSAGE":   2,
	"BROADCAST": 3,
	"UNKNOWN":   99,
}

func (x ObjectType) String() string {
	return proto.EnumName(ObjectType_name, int32(x))
}
func (ObjectType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type GetIdentityRequest struct {
	// A properly formatted Bitmessage address.
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
}

func (m *GetIdentityRequest) Reset()                    { *m = GetIdentityRequest{} }
func (m *GetIdentityRequest) String() string            { return proto.CompactTextString(m) }
func (*GetIdentityRequest) ProtoMessage()               {}
func (*GetIdentityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type GetIdentityReply struct {
	// Nonce Trials Per Byte: POW parameter.
	NonceTrials uint64 `protobuf:"varint,1,opt,name=nonce_trials,json=nonceTrials" json:"nonce_trials,omitempty"`
	// Extra bytes: POW parameter.
	ExtraBytes uint64 `protobuf:"varint,2,opt,name=extra_bytes,json=extraBytes" json:"extra_bytes,omitempty"`
	// Uncompressed secp256k1 public key.
	SigningKey []byte `protobuf:"bytes,3,opt,name=signing_key,json=signingKey,proto3" json:"signing_key,omitempty"`
	// Uncompressed secp256k1 public key.
	EncryptionKey []byte `protobuf:"bytes,4,opt,name=encryption_key,json=encryptionKey,proto3" json:"encryption_key,omitempty"`
	Behavior      uint32 `protobuf:"varint,5,opt,name=behavior" json:"behavior,omitempty"`
}

func (m *GetIdentityReply) Reset()                    { *m = GetIdentityReply{} }
func (m *GetIdentityReply) String() string            { return proto.CompactTextString(m) }
func (*GetIdentityReply) ProtoMessage()               {}
func (*GetIdentityReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Object struct {
	// Properly serialized object bytes. It includes the object header (but not
	// the Bitmessage message header).
	Contents []byte `protobuf:"bytes,1,opt,name=contents,proto3" json:"contents,omitempty"`
	// Counter value of the object, as in bmd's database. It is ignored with
	// SendObject.
	Counter uint64 `protobuf:"varint,2,opt,name=counter" json:"counter,omitempty"`
}

func (m *Object) Reset()                    { *m = Object{} }
func (m *Object) String() string            { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()               {}
func (*Object) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type SendObjectReply struct {
	// Counter value of the object, as inserted in bmd's database.
	Counter uint64 `protobuf:"varint,1,opt,name=counter" json:"counter,omitempty"`
}

func (m *SendObjectReply) Reset()                    { *m = SendObjectReply{} }
func (m *SendObjectReply) String() string            { return proto.CompactTextString(m) }
func (*SendObjectReply) ProtoMessage()               {}
func (*SendObjectReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type GetObjectsRequest struct {
	// Type of object the client wants to receive.
	ObjectType ObjectType `protobuf:"varint,1,opt,name=object_type,json=objectType,enum=ObjectType" json:"object_type,omitempty"`
	// Counter value the server should start sending object messages from.
	FromCounter uint64 `protobuf:"varint,2,opt,name=from_counter,json=fromCounter" json:"from_counter,omitempty"`
}

func (m *GetObjectsRequest) Reset()                    { *m = GetObjectsRequest{} }
func (m *GetObjectsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetObjectsRequest) ProtoMessage()               {}
func (*GetObjectsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func init() {
	proto.RegisterType((*GetIdentityRequest)(nil), "GetIdentityRequest")
	proto.RegisterType((*GetIdentityReply)(nil), "GetIdentityReply")
	proto.RegisterType((*Object)(nil), "Object")
	proto.RegisterType((*SendObjectReply)(nil), "SendObjectReply")
	proto.RegisterType((*GetObjectsRequest)(nil), "GetObjectsRequest")
	proto.RegisterEnum("ObjectType", ObjectType_name, ObjectType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Bmd service

type BmdClient interface {
	// Retrieve the public identity of the given address. This is constructed from
	// public keys stored in the database. If the public key for the specified
	// address doesn't exist, an error is returned.
	GetIdentity(ctx context.Context, in *GetIdentityRequest, opts ...grpc.CallOption) (*GetIdentityReply, error)
	// Send the specified object onto the network. The object is first verified,
	// then inserted into bmd's database and advertised onto the network. Return
	// value is the counter value of the inserted object.
	SendObject(ctx context.Context, in *Object, opts ...grpc.CallOption) (*SendObjectReply, error)
	// Gets objects of the specified type that have their counter values starting
	// from what is specified. This method streams new objects until the stream
	// is closed. Objects are guaranteed to be in ascending order.
	GetObjects(ctx context.Context, in *GetObjectsRequest, opts ...grpc.CallOption) (Bmd_GetObjectsClient, error)
}

type bmdClient struct {
	cc *grpc.ClientConn
}

func NewBmdClient(cc *grpc.ClientConn) BmdClient {
	return &bmdClient{cc}
}

func (c *bmdClient) GetIdentity(ctx context.Context, in *GetIdentityRequest, opts ...grpc.CallOption) (*GetIdentityReply, error) {
	out := new(GetIdentityReply)
	err := grpc.Invoke(ctx, "/Bmd/GetIdentity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bmdClient) SendObject(ctx context.Context, in *Object, opts ...grpc.CallOption) (*SendObjectReply, error) {
	out := new(SendObjectReply)
	err := grpc.Invoke(ctx, "/Bmd/SendObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bmdClient) GetObjects(ctx context.Context, in *GetObjectsRequest, opts ...grpc.CallOption) (Bmd_GetObjectsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Bmd_serviceDesc.Streams[0], c.cc, "/Bmd/GetObjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &bmdGetObjectsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Bmd_GetObjectsClient interface {
	Recv() (*Object, error)
	grpc.ClientStream
}

type bmdGetObjectsClient struct {
	grpc.ClientStream
}

func (x *bmdGetObjectsClient) Recv() (*Object, error) {
	m := new(Object)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Bmd service

type BmdServer interface {
	// Retrieve the public identity of the given address. This is constructed from
	// public keys stored in the database. If the public key for the specified
	// address doesn't exist, an error is returned.
	GetIdentity(context.Context, *GetIdentityRequest) (*GetIdentityReply, error)
	// Send the specified object onto the network. The object is first verified,
	// then inserted into bmd's database and advertised onto the network. Return
	// value is the counter value of the inserted object.
	SendObject(context.Context, *Object) (*SendObjectReply, error)
	// Gets objects of the specified type that have their counter values starting
	// from what is specified. This method streams new objects until the stream
	// is closed. Objects are guaranteed to be in ascending order.
	GetObjects(*GetObjectsRequest, Bmd_GetObjectsServer) error
}

func RegisterBmdServer(s *grpc.Server, srv BmdServer) {
	s.RegisterService(&_Bmd_serviceDesc, srv)
}

func _Bmd_GetIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BmdServer).GetIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Bmd/GetIdentity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BmdServer).GetIdentity(ctx, req.(*GetIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bmd_SendObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Object)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BmdServer).SendObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Bmd/SendObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BmdServer).SendObject(ctx, req.(*Object))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bmd_GetObjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetObjectsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BmdServer).GetObjects(m, &bmdGetObjectsServer{stream})
}

type Bmd_GetObjectsServer interface {
	Send(*Object) error
	grpc.ServerStream
}

type bmdGetObjectsServer struct {
	grpc.ServerStream
}

func (x *bmdGetObjectsServer) Send(m *Object) error {
	return x.ServerStream.SendMsg(m)
}

var _Bmd_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Bmd",
	HandlerType: (*BmdServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetIdentity",
			Handler:    _Bmd_GetIdentity_Handler,
		},
		{
			MethodName: "SendObject",
			Handler:    _Bmd_SendObject_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetObjects",
			Handler:       _Bmd_GetObjects_Handler,
			ServerStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("rpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 419 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x64, 0x92, 0xdf, 0x8e, 0x93, 0x40,
	0x14, 0x87, 0x65, 0xbb, 0xb6, 0xdb, 0x43, 0xbb, 0xb2, 0xe3, 0x0d, 0xe1, 0x46, 0x25, 0x31, 0x1a,
	0xd7, 0x10, 0xb3, 0xc6, 0x5b, 0x93, 0x52, 0x49, 0x63, 0x1a, 0xdb, 0x66, 0xa0, 0x31, 0x7a, 0x43,
	0xf8, 0x33, 0x56, 0xb4, 0x9d, 0xc1, 0x61, 0x6a, 0xe4, 0x35, 0x7c, 0x1c, 0x9f, 0x4e, 0x66, 0x80,
	0xd2, 0x6e, 0xaf, 0x98, 0xf3, 0xf1, 0x1d, 0x32, 0xe7, 0xc7, 0x81, 0x21, 0xcf, 0x13, 0x27, 0xe7,
	0x4c, 0x30, 0xdb, 0x01, 0x34, 0x23, 0xe2, 0x63, 0x4a, 0xa8, 0xc8, 0x44, 0x89, 0xc9, 0xaf, 0x3d,
	0x29, 0x04, 0x32, 0x61, 0x10, 0xa5, 0x29, 0x27, 0x45, 0x61, 0x6a, 0x4f, 0xb5, 0x97, 0x43, 0xdc,
	0x96, 0xf6, 0x3f, 0x0d, 0x8c, 0x93, 0x86, 0x7c, 0x5b, 0xa2, 0x67, 0x30, 0xa2, 0x8c, 0x26, 0x24,
	0x14, 0x3c, 0x8b, 0xb6, 0x75, 0xcf, 0x25, 0xd6, 0x15, 0x0b, 0x14, 0x42, 0x4f, 0x40, 0x27, 0x7f,
	0x04, 0x8f, 0xc2, 0xb8, 0x14, 0xa4, 0x30, 0x2f, 0x94, 0x01, 0x0a, 0xb9, 0x92, 0x48, 0xa1, 0xc8,
	0x36, 0x34, 0xa3, 0x9b, 0xf0, 0x27, 0x29, 0xcd, 0x5e, 0x25, 0x8c, 0x30, 0x34, 0x68, 0x4e, 0x4a,
	0xf4, 0x1c, 0xae, 0x09, 0x4d, 0x78, 0x99, 0x8b, 0x8c, 0x51, 0xe5, 0x5c, 0x2a, 0x67, 0xdc, 0x51,
	0xa9, 0x59, 0x70, 0x15, 0x93, 0xef, 0xd1, 0xef, 0x8c, 0x71, 0xf3, 0x61, 0x25, 0x8c, 0xf1, 0xa1,
	0xb6, 0xdf, 0x43, 0x7f, 0x19, 0xff, 0x20, 0x89, 0x90, 0x56, 0xc2, 0xa8, 0xa8, 0x86, 0xa8, 0x6f,
	0x3b, 0xc2, 0x87, 0x5a, 0x0e, 0x9f, 0xb0, 0x7d, 0x55, 0xf0, 0xe6, 0x9a, 0x6d, 0x69, 0xdf, 0xc2,
	0x23, 0x9f, 0xd0, 0xb4, 0xfe, 0x46, 0x3d, 0xfa, 0x91, 0xac, 0x9d, 0xca, 0x29, 0xdc, 0x54, 0x41,
	0xd5, 0x6e, 0xd1, 0x06, 0xfb, 0x1a, 0x74, 0xa6, 0x48, 0x28, 0xca, 0x9c, 0xa8, 0x96, 0xeb, 0x3b,
	0xdd, 0xa9, 0xad, 0xa0, 0x42, 0x18, 0xd8, 0xe1, 0x2c, 0x73, 0xfd, 0xc6, 0xd9, 0x2e, 0x3c, 0xbd,
	0x8e, 0x2e, 0xd9, 0xb4, 0x46, 0xaf, 0x56, 0x00, 0x5d, 0x33, 0x1a, 0xc3, 0x70, 0xe6, 0x05, 0xab,
	0xb5, 0x3b, 0xf7, 0xbe, 0x18, 0x0f, 0x10, 0x40, 0xbf, 0x39, 0x6b, 0x48, 0x87, 0xc1, 0x27, 0xcf,
	0xf7, 0x27, 0x33, 0xcf, 0xb8, 0x90, 0x9e, 0x8b, 0x97, 0x93, 0x0f, 0xd3, 0x89, 0x1f, 0x18, 0x3d,
	0xf9, 0x6e, 0xbd, 0x98, 0x2f, 0x96, 0x9f, 0x17, 0x46, 0x72, 0xf7, 0x57, 0x83, 0x9e, 0xbb, 0x4b,
	0xd1, 0x3b, 0xd0, 0x8f, 0x7e, 0x34, 0x7a, 0xec, 0x9c, 0xef, 0x89, 0x75, 0xe3, 0x9c, 0xed, 0xc2,
	0x0b, 0x80, 0x2e, 0x23, 0x34, 0x68, 0x46, 0xb3, 0x0c, 0xe7, 0x7e, 0x72, 0xb7, 0x00, 0x5d, 0x3e,
	0x08, 0x39, 0x67, 0x61, 0x59, 0x6d, 0xf3, 0x1b, 0xcd, 0x85, 0xaf, 0x57, 0xd5, 0xce, 0xaa, 0x95,
	0x8d, 0xfb, 0xea, 0xf1, 0xf6, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x79, 0x31, 0xe4, 0xb8, 0xc6,
	0x02, 0x00, 0x00,
}
