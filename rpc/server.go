// Originally derived from: btcsuite/btcd/rpcserver.go
// Copyright (c) 2013-2015 The btcsuite developers.

// Copyright (c) 2015 Monetas.
// Copyright 2016 Daniel Krawisz.
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package rpc

import (
	"crypto/sha256"
	"crypto/subtle"
	"encoding/base64"
	"errors"
	"fmt"
	"io/ioutil"
	prand "math/rand"
	"net"
	"os"
	"sync"
	"time"

	"github.com/btcsuite/btcutil"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/metadata"
)

// genCertPair generates a key/cert pair to the paths provided.
func genCertPair(certFile, keyFile string) error {
	rpcLog.Infof("Generating TLS certificates...")

	org := "bmd autogenerated cert"
	validUntil := time.Now().Add(10 * 365 * 24 * time.Hour)
	cert, key, err := btcutil.NewTLSCertPair(org, validUntil, nil)
	if err != nil {
		return err
	}

	// Write cert and key files.
	if err = ioutil.WriteFile(certFile, cert, 0666); err != nil {
		return err
	}
	if err = ioutil.WriteFile(keyFile, key, 0600); err != nil {
		os.Remove(certFile)
		return err
	}

	rpcLog.Infof("Done generating TLS certificates")
	return nil
}

// Server holds the items the rpc server may need to access (config,
// shutdown, main server, etc.)
type Server struct {
	sync.Mutex
	on bool
	wg sync.WaitGroup

	rpcSrv       *grpc.Server
	listeners    []net.Listener
	limitauthsha [sha256.Size]byte
	authsha      [sha256.Size]byte
}

// GRPC returns the grpc server.
func (s *Server) GRPC() *grpc.Server {
	return s.rpcSrv
}

// RestrictAuth restricts access of the client, returning an error if the client
// is not already authenticated.
func (s *Server) RestrictAuth(ctx context.Context) codes.Code {
	md, ok := metadata.FromContext(ctx)
	if !ok {
		return codes.Unauthenticated
	}
	login, ok := md["authorization"]
	if !ok {
		return codes.Unauthenticated
	}

	authsha := sha256.Sum256([]byte(login[0]))

	// Check for limited auth first as in environments with limited users, those
	// are probably expected to have a higher volume of calls
	limitcmp := subtle.ConstantTimeCompare(authsha[:], s.limitauthsha[:])
	if limitcmp == 1 {
		return codes.OK
	}

	// Check for admin-level auth
	cmp := subtle.ConstantTimeCompare(authsha[:], s.authsha[:])
	if cmp == 1 {
		return codes.OK
	}

	return codes.PermissionDenied
}

// RestrictAdmin restricts access of the client, returning an error if the
// client is not already authenticated as an admin.
func (s *Server) RestrictAdmin(ctx context.Context) codes.Code {
	md, ok := metadata.FromContext(ctx)
	if !ok {
		return codes.Unauthenticated
	}
	login, ok := md["authorization"]
	if !ok {
		return codes.Unauthenticated
	}

	authsha := sha256.Sum256([]byte(login[0]))
	// Check for admin-level auth
	cmp := subtle.ConstantTimeCompare(authsha[:], s.authsha[:])
	if cmp == 1 {
		return codes.OK
	}

	return codes.PermissionDenied
}

// NewRPCServer returns a new instance of the Server struct.
func NewRPCServer(cfg *Config) (*Server, error) {

	// Setup TLS if not disabled.
	listenFunc := net.Listen
	var opts []grpc.ServerOption
	if !cfg.DisableTLS {
		if !FileExists(cfg.Key) && !FileExists(cfg.Cert) {
			err := genCertPair(cfg.Cert, cfg.Key)
			if err != nil {
				return nil, err
			}
		}

		creds, err := credentials.NewServerTLSFromFile(cfg.Cert, cfg.Key)
		if err != nil {
			return nil, fmt.Errorf("Failed to generate credentials %v", err)
		}
		opts = []grpc.ServerOption{grpc.Creds(creds)}
	}

	rpc := Server{
		rpcSrv: grpc.NewServer(opts...), // Create the underlying RPC server.
	}
	//pb.RegisterBmdServer(rpc.rpcSrv, &rpc)

	if cfg.User != "" && cfg.Pass != "" {
		login := base64.StdEncoding.EncodeToString([]byte(cfg.User + ":" +
			cfg.Pass))
		rpc.authsha = sha256.Sum256([]byte("Basic " + login))
	}
	if cfg.LimitUser != "" && cfg.LimitPass != "" {
		login := base64.StdEncoding.EncodeToString([]byte(cfg.LimitUser + ":" +
			cfg.LimitPass))
		rpc.limitauthsha = sha256.Sum256([]byte("Basic " + login))
	}

	ipv4ListenAddrs, ipv6ListenAddrs, err := ParseListeners(cfg.Listeners)
	if err != nil {
		return nil, err
	}
	listeners := make([]net.Listener, 0,
		len(ipv6ListenAddrs)+len(ipv4ListenAddrs))

	for _, addr := range ipv4ListenAddrs {
		listener, err := listenFunc("tcp4", addr)
		if err != nil {
			rpcLog.Warnf("Can't listen on %s: %v", addr, err)
			continue
		}
		listeners = append(listeners, listener)
	}

	for _, addr := range ipv6ListenAddrs {
		listener, err := listenFunc("tcp6", addr)
		if err != nil {
			rpcLog.Warnf("Can't listen on %s: %v", addr, err)
			continue
		}
		listeners = append(listeners, listener)
	}
	if len(listeners) == 0 {
		return nil, errors.New("RPC: No valid listen address")
	}

	rpc.listeners = listeners
	return &rpc, nil
}

// Stop is used by server.go to stop the rpc listener.
func (s *Server) Stop() error {
	s.Lock()
	defer s.Unlock()

	if !s.on {
		return nil
	}

	rpcLog.Warnf("RPC server shutting down")

	for _, listener := range s.listeners {
		err := listener.Close()
		if err != nil {
			rpcLog.Errorf("Problem shutting down rpc: %v", err)
			return err
		}
	}

	s.wg.Wait()
	rpcLog.Infof("RPC server shutdown complete")
	return nil
}

// Running tells whether the server is running.
func (s *Server) Running() bool {
	return s.on
}

// Start is used by server.go to start the rpc listener.
func (s *Server) Start() {
	s.Lock()
	defer s.Unlock()

	if s.on {
		return
	}

	rpcLog.Trace("Starting RPC server")

	// Start listening on the listeners.
	for _, listener := range s.listeners {
		s.wg.Add(1)
		go func(listener net.Listener) {
			rpcLog.Infof("RPC server listening on %s", listener.Addr())
			s.rpcSrv.Serve(listener)
			rpcLog.Tracef("RPC listener done for %s", listener.Addr())
			s.wg.Done()
		}(listener)
	}

	s.on = true
}

func init() {
	prand.Seed(time.Now().UnixNano())
}
